<!DOCTYPE html>
<html>
    <head>
        <title>Cubes - 3DINT 1st Proj.</title>
        <meta charset="utf-8">
        <link rel="stylesheet" type="text/css" href="main.css">
    </head>
    <body>

        <!-- shaders for UnrealBloom pass --> 
        <script type="x-shader/x-vertex" id="vs">
            varying vec2 vUv;

            void main() {

                vUv = uv;

                gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
            }
        
        </script>

        <script type="x-shader/x-fragment" id="fs">
            uniform sampler2D baseTexture;
            uniform sampler2D bloomTexture;

            varying vec2 vUv;

            void main() {
                gl_FragColor = ( texture2D( baseTexture, vUv ) ) + vec4( 1.0 ) * texture2D( bloomTexture, vUv );
            }

        </script>

        <script type="module">

            // modules import
            import * as THREE from 'https://unpkg.com/three@0.120.0/build/three.module.js';
            import Stats from 'https://unpkg.com/three@0.120.0/examples/jsm/libs/stats.module.js';
            import { OrbitControls } from 'https://unpkg.com/three@0.120.0/examples/jsm/controls/OrbitControls.js';
            import { EffectComposer } from 'https://unpkg.com/three@0.120.0/examples/jsm/postprocessing/EffectComposer.js';
            import { RenderPass } from 'https://unpkg.com/three@0.120.0/examples/jsm/postprocessing/RenderPass.js';
            import { ShaderPass } from 'https://unpkg.com/three@0.120.0/examples/jsm/postprocessing/ShaderPass.js';
            import { UnrealBloomPass } from 'https://unpkg.com/three@0.120.0/examples/jsm/postprocessing/UnrealBloomPass.js';
            import { Terrain } from './obj/Terrain.js';
            import { Flame } from './obj/Flame.js'
        
            var BLOOM_SCENE = 1;
            var pivot1, pivot2;
            var bloomComposer, bloomPass, renderPass, finalPass, finalComposer, darkMaterial, materials;
            var scene, camera, renderer, clearColor, bloomLayer, params, controls, stats, clock, timedelta;
            var dirLight, dirLightSize, hemiLight, flame, terrain;
            
            function Setup() {

                scene = new THREE.Scene();

                // - - WebGL renderer init
                renderer = new THREE.WebGLRenderer({
                    antialias: true,
                    toneMapping: THREE.ReinhardToneMapping,
                    encoding: THREE.GammaEncoding,        
                });

                clearColor = new THREE.Color(0.9,0.9,0.9);
                renderer.setSize( window.innerWidth, window.innerHeight );
                renderer.setClearColor( clearColor );
                renderer.setPixelRatio( window.devicePixelRatio );
                document.body.appendChild( renderer.domElement );

                // enable shadowmaps
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;

                // - - camera
                camera = new THREE.PerspectiveCamera(
                    75,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    1000
                );
                camera.position.set(8,2,8);
                camera.lookAt( new THREE.Vector3(0,0,0));

                // - - bloom layer
                bloomLayer = new THREE.Layers();
                bloomLayer.set( BLOOM_SCENE );

                params = {
                    exposure: 1.0,
                    bloomStrength : 1.75,
                    bloomThreshold: 0,
                    bloomRadius: 0,
                    scene: "Only emissive light sources"
                }

                renderPass = new RenderPass( scene, camera );
                bloomPass = new UnrealBloomPass( new THREE.Vector2( window.innerWidth, window.innerHeight ), 1.5, 0.4, 0.85 );
                bloomPass.threshold = params.bloomThreshold;
                bloomPass.strength = params.bloomStrength;
                bloomPass.radius = params.bloomRadius;

                bloomComposer = new EffectComposer( renderer );
                bloomComposer.renderToScreen = false;
                bloomComposer.addPass( renderPass );
                bloomComposer.addPass( bloomPass );
                materials = {};
                darkMaterial = new THREE.MeshBasicMaterial( { color: "black" } );
                

                finalPass = new ShaderPass(
                    new THREE.ShaderMaterial( {
                        uniforms: {
                            baseTexture: { value: null },
                            bloomTexture: { value: bloomComposer.renderTarget2.texture }
                        },
                        vertexShader: document.getElementById( 'vs' ).textContent,
                        fragmentShader: document.getElementById( 'fs' ).textContent,
                        defines: {}
                    } ), "baseTexture"
                );
                finalPass.needsSwap = true;

                finalComposer = new EffectComposer( renderer );
                finalComposer.addPass( renderPass );
                finalComposer.addPass( finalPass );
                
                // - - stats
                stats = new Stats();
                document.body.appendChild( stats.domElement );

                // - - orbit controls
                controls = new OrbitControls( camera, renderer.domElement );
                controls.addEventListener( 'change', Render );
                //controls.maxPolarAngle = Math.PI * 0.5;
                controls.minDistance = 1;
                controls.maxDistance = 10000;
            
                // - - clock for animations
                clock = new THREE.Clock();
                timedelta = 0;
                
            }

            function BuildScene() {
                // - - scene lights
                hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.6 );
                hemiLight.color.setHSL( 0.6, 1, 0.6 );
                hemiLight.groundColor.setHSL( 0.095, 1, 0.75 );
                hemiLight.position.set( 0, 500, 0 );
                scene.add( hemiLight );

                dirLightSize = 30;
                dirLight = new THREE.DirectionalLight( 0xffffff, 1 );
                dirLight.color.setHSL( 0.1, 1, 0.95 );
                dirLight.position.set( 0, 1.0, 1.0 );
                dirLight.position.multiplyScalar( 50 );
                dirLight.castShadow = true;
                dirLight.shadow.mapSize.width = 2048;
                dirLight.shadow.mapSize.height = 2048;
                dirLight.shadow.bias = - 0.0005;
                dirLight.shadow.camera.left = -dirLightSize;
                dirLight.shadow.camera.right = dirLightSize;
                dirLight.shadow.camera.top = dirLightSize;
                dirLight.shadow.camera.bottom = -dirLightSize;
                scene.add( dirLight );

                // so... it is not working
                var helper = new THREE.CameraHelper( dirLight.shadow.camera );
                scene.add( helper );

                // - - objects
                /*flame = new Flame( 2.0, BLOOM_SCENE );
                scene.add(flame.getMesh());
                flame.getMesh().position.set(
                    0,
                    10,
                    0
                );
                flame.start();*/

                // terrain
                terrain = new Terrain( 'texture/terrain.png', 1.0, 7, 2, 7 );
                //terrain = new Terrain( 'texture/terrain2.png', 0.1 );
                scene.add(terrain.getMesh());
                terrain.loadTerrain();

            }
            
            function Update() {
                requestAnimationFrame( Update );
                controls.update();  
                stats.update();
                Animate();
                Render();
            }
            
            function Render() {
                //renderer.render(scene, camera);
                renderBloom();
                finalComposer.render();


            }

            function Animate() {       
                timedelta = clock.getDelta();
                //flame.animate(timedelta);
                dirLight.position.z -= 0.1;
            }
            
            function renderBloom() {
                scene.traverse( darkenNonBloomed );
                renderer.setClearColor( 0x000000 );
                bloomComposer.render();
                renderer.setClearColor( clearColor );
                scene.traverse( restoreMaterial );
            }

            function darkenNonBloomed( obj ) {

                if ( obj.isMesh && bloomLayer.test( obj.layers ) === false ) {

                    materials[ obj.uuid ] = obj.material;
                    obj.material = darkMaterial;

                }

            }

            function restoreMaterial( obj ) {

                if ( materials[ obj.uuid ] ) {

                    obj.material = materials[ obj.uuid ];
                    delete materials[ obj.uuid ];

                }

            }

            Setup();
            BuildScene();
            Update();
            
        </script>
    </body>
</html>